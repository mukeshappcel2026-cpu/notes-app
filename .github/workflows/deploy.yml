name: Deploy to AWS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - eks-prod
  workflow_run:
    workflows: ["CI - Test Application"]
    types: [completed]
    branches: [main]

permissions:
  id-token: write   # Required for OIDC
  contents: read

jobs:
  # ------------------------------------------------------------------
  # Job 1: Build Docker image and push to ECR
  #
  # Shared by both dev (EC2) and eks-prod (EKS) deploy paths.
  # ------------------------------------------------------------------
  build:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    # Only deploy if CI passed (workflow_run) or if manually triggered (workflow_dispatch)
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')

    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}
      api_repo_url: ${{ steps.ecr-repos.outputs.api_repo_url }}
      worker_repo_url: ${{ steps.ecr-repos.outputs.worker_repo_url }}
      deploy_env: ${{ steps.meta.outputs.deploy_env }}

    env:
      DEPLOY_ENV: ${{ github.event.inputs.environment || 'dev' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha || github.sha }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set image metadata
        id: meta
        run: |
          IMAGE_TAG="${{ github.event.workflow_run.head_sha || github.sha }}"
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "deploy_env=$DEPLOY_ENV" >> $GITHUB_OUTPUT
          echo "Image tag: $IMAGE_TAG"
          echo "Deploy env: $DEPLOY_ENV"

      - name: Get ECR repository URLs
        id: ecr-repos
        run: |
          if [ "$DEPLOY_ENV" = "eks-prod" ]; then
            # EKS uses separate repos for api and worker
            API_REPO=$(aws ecr describe-repositories \
              --repository-names "notesapp-app" \
              --query 'repositories[0].repositoryUri' --output text)
            WORKER_REPO=$(aws ecr describe-repositories \
              --repository-names "notesapp-worker" \
              --query 'repositories[0].repositoryUri' --output text)
          else
            # Dev uses a single repo
            API_REPO=$(aws ecr describe-repositories \
              --repository-names "notesapp-${DEPLOY_ENV}" \
              --query 'repositories[0].repositoryUri' --output text)
            WORKER_REPO=""
          fi
          echo "api_repo_url=$API_REPO" >> $GITHUB_OUTPUT
          echo "worker_repo_url=$WORKER_REPO" >> $GITHUB_OUTPUT
          echo "API ECR repo: $API_REPO"
          echo "Worker ECR repo: $WORKER_REPO"

      - name: Build and push API image
        env:
          ECR_REPO: ${{ steps.ecr-repos.outputs.api_repo_url }}
          IMAGE_TAG: ${{ steps.meta.outputs.image_tag }}
        run: |
          docker build -t $ECR_REPO:$IMAGE_TAG -t $ECR_REPO:latest .
          docker push $ECR_REPO:$IMAGE_TAG
          docker push $ECR_REPO:latest
          echo "Pushed $ECR_REPO:$IMAGE_TAG"

      - name: Build and push Worker image
        if: env.DEPLOY_ENV == 'eks-prod'
        env:
          ECR_REPO: ${{ steps.ecr-repos.outputs.worker_repo_url }}
          IMAGE_TAG: ${{ steps.meta.outputs.image_tag }}
        run: |
          # Worker uses the same Dockerfile (same Node.js app, different entry command)
          docker build -t $ECR_REPO:$IMAGE_TAG -t $ECR_REPO:latest .
          docker push $ECR_REPO:$IMAGE_TAG
          docker push $ECR_REPO:latest
          echo "Pushed $ECR_REPO:$IMAGE_TAG"

  # ------------------------------------------------------------------
  # Job 2a: Deploy to EC2 (dev environment)
  # ------------------------------------------------------------------
  deploy-ec2:
    name: Deploy to EC2
    needs: build
    if: needs.build.outputs.deploy_env == 'dev'
    runs-on: ubuntu-latest
    environment: dev

    env:
      DYNAMODB_TABLE: ${{ vars.DYNAMODB_TABLE || 'Notes' }}
      GOOGLE_CLIENT_ID: ${{ vars.GOOGLE_CLIENT_ID }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Get EC2 instance ID
        id: get-instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=NotesApp-*-EC2" \
                      "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "Found instance: $INSTANCE_ID"

      - name: Deploy container to EC2 via SSM
        env:
          ECR_REPO: ${{ needs.build.outputs.api_repo_url }}
          IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
          REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids ${{ steps.get-instance.outputs.instance_id }} \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              \"set -e\",
              \"echo 'Starting Docker deployment...'\",
              \"REGION=${REGION}\",
              \"ACCOUNT_ID=\$(aws sts get-caller-identity --query Account --output text --region \$REGION)\",
              \"aws ecr get-login-password --region \$REGION | docker login --username AWS --password-stdin \$ACCOUNT_ID.dkr.ecr.\$REGION.amazonaws.com\",
              \"docker pull ${ECR_REPO}:${IMAGE_TAG}\",
              \"docker stop notes-app || true\",
              \"docker rm notes-app || true\",
              \"docker run -d --name notes-app --restart unless-stopped -p 3000:3000 -e PORT=3000 -e AWS_REGION=${REGION} -e DYNAMODB_TABLE=${DYNAMODB_TABLE} -e GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID} -e NODE_ENV=production -v /home/ec2-user/notes-app/logs:/app/logs ${ECR_REPO}:${IMAGE_TAG}\",
              \"echo 'Deployment complete!'\",
              \"docker ps\"
            ]" \
            --comment "Deploying notes-app:${IMAGE_TAG}" \
            --query "Command.CommandId" \
            --output text)

          echo "SSM Command ID: $COMMAND_ID"

          for i in $(seq 1 30); do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id ${{ steps.get-instance.outputs.instance_id }} \
              --query "Status" --output text 2>/dev/null || echo "Pending")
            echo "Command status: $STATUS"
            if [ "$STATUS" = "Success" ]; then
              echo "SSM command completed successfully"
              break
            elif [ "$STATUS" = "Failed" ] || [ "$STATUS" = "TimedOut" ]; then
              echo "SSM command failed with status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id ${{ steps.get-instance.outputs.instance_id }}
              exit 1
            fi
            sleep 10
          done

      - name: Health check
        run: |
          INSTANCE_IP=$(aws ec2 describe-instances \
            --instance-ids ${{ steps.get-instance.outputs.instance_id }} \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)

          echo "Testing health endpoint: http://${INSTANCE_IP}:3000/health"

          for i in $(seq 1 10); do
            if curl -sf "http://${INSTANCE_IP}:3000/health"; then
              echo ""
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i failed, retrying..."
            sleep 10
          done

          echo "Health check failed after 10 attempts"
          exit 1

      - name: Rollback on failure
        if: failure()
        env:
          REGION: ${{ vars.AWS_REGION || 'us-east-1' }}
        run: |
          echo "Deployment failed, rolling back to previous container..."
          aws ssm send-command \
            --instance-ids ${{ steps.get-instance.outputs.instance_id }} \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              \"docker stop notes-app || true\",
              \"docker rm notes-app || true\",
              \"PREVIOUS=\$(docker images --format '{{.Repository}}:{{.Tag}}' | grep notesapp | grep -v latest | head -2 | tail -1)\",
              \"if [ -n \\\"\$PREVIOUS\\\" ]; then docker run -d --name notes-app --restart unless-stopped -p 3000:3000 -e PORT=3000 -e AWS_REGION=${REGION} -e DYNAMODB_TABLE=${DYNAMODB_TABLE} -e GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID} -e NODE_ENV=production -v /home/ec2-user/notes-app/logs:/app/logs \$PREVIOUS; fi\",
              \"docker ps\"
            ]" \
            --comment "Rolling back notes-app deployment"

  # ------------------------------------------------------------------
  # Job 2b: Deploy to EKS (eks-prod environment)
  #
  # Uses kubectl to update the Deployment images in the EKS cluster.
  # The K8s resources (Deployments, Services, Ingress) are managed by
  # Terraform in notes-infrastructure. This job only updates the image.
  # ------------------------------------------------------------------
  deploy-eks:
    name: Deploy to EKS
    needs: build
    if: needs.build.outputs.deploy_env == 'eks-prod'
    runs-on: ubuntu-latest
    environment: eks-prod

    env:
      CLUSTER_NAME: notes-cluster
      NAMESPACE: prod

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name $CLUSTER_NAME \
            --region ${{ vars.AWS_REGION || 'us-east-1' }}
          echo "Connected to EKS cluster:"
          kubectl cluster-info

      - name: Update API Deployment image
        env:
          IMAGE: ${{ needs.build.outputs.api_repo_url }}:${{ needs.build.outputs.image_tag }}
        run: |
          echo "Updating notes-api to $IMAGE"
          kubectl set image deployment/notes-api \
            notes-api=$IMAGE \
            -n $NAMESPACE
          echo "API deployment image updated"

      - name: Update Worker Deployment image
        env:
          IMAGE: ${{ needs.build.outputs.worker_repo_url }}:${{ needs.build.outputs.image_tag }}
        run: |
          echo "Updating notes-worker to $IMAGE"
          kubectl set image deployment/notes-worker \
            notes-worker=$IMAGE \
            -n $NAMESPACE
          echo "Worker deployment image updated"

      - name: Wait for API rollout
        run: |
          echo "Waiting for notes-api rollout..."
          kubectl rollout status deployment/notes-api \
            -n $NAMESPACE --timeout=300s

      - name: Wait for Worker rollout
        run: |
          echo "Waiting for notes-worker rollout..."
          kubectl rollout status deployment/notes-worker \
            -n $NAMESPACE --timeout=300s

      - name: Verify deployment
        run: |
          echo "=== Pods ==="
          kubectl get pods -n $NAMESPACE -o wide
          echo ""
          echo "=== Services ==="
          kubectl get svc -n $NAMESPACE
          echo ""
          echo "=== Ingress ==="
          kubectl get ingress -n $NAMESPACE
          echo ""
          echo "=== Recent events ==="
          kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | tail -20

      - name: Health check via ALB
        run: |
          ALB_DNS=$(aws elbv2 describe-load-balancers \
            --names "NotesApp-prod-ALB" \
            --query 'LoadBalancers[0].DNSName' --output text 2>/dev/null || echo "")

          if [ -z "$ALB_DNS" ] || [ "$ALB_DNS" = "None" ]; then
            echo "ALB not found, skipping external health check"
            echo "Checking pod health directly..."
            kubectl exec -n $NAMESPACE deploy/notes-api -- \
              wget -q --spider http://localhost:3000/health 2>/dev/null || \
              echo "Pod health check skipped (wget not available)"
            exit 0
          fi

          echo "Testing health endpoint: http://${ALB_DNS}/health"

          for i in $(seq 1 15); do
            if curl -sf "http://${ALB_DNS}/health" --max-time 5; then
              echo ""
              echo "ALB health check passed!"
              exit 0
            fi
            echo "Attempt $i/15 - waiting for ALB target registration..."
            sleep 20
          done

          echo "Warning: ALB health check timed out (targets may still be registering)"
          echo "Pods are running - ALB target registration can take a few minutes"

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed, rolling back..."
          kubectl rollout undo deployment/notes-api -n $NAMESPACE || true
          kubectl rollout undo deployment/notes-worker -n $NAMESPACE || true
          echo "Rollback initiated"
          kubectl get pods -n $NAMESPACE

  # ------------------------------------------------------------------
  # Job 3: Post-deployment smoke tests
  # ------------------------------------------------------------------
  post-deploy-tests:
    name: Post-Deployment Tests
    needs: [build, deploy-ec2, deploy-eks]
    # Run if either deploy job succeeded (the other will be skipped)
    if: always() && (needs.deploy-ec2.result == 'success' || needs.deploy-eks.result == 'success')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION || 'us-east-1' }}

      - name: Get API URL
        id: get-url
        env:
          DEPLOY_ENV: ${{ needs.build.outputs.deploy_env }}
        run: |
          if [ "$DEPLOY_ENV" = "eks-prod" ]; then
            # Get ALB DNS for EKS
            ALB_DNS=$(aws elbv2 describe-load-balancers \
              --names "NotesApp-prod-ALB" \
              --query 'LoadBalancers[0].DNSName' --output text)
            echo "api_url=http://${ALB_DNS}" >> $GITHUB_OUTPUT
          else
            # Get EC2 IP for dev
            INSTANCE_IP=$(aws ec2 describe-instances \
              --filters "Name=tag:Name,Values=NotesApp-*-EC2" \
                        "Name=instance-state-name,Values=running" \
              --query "Reservations[0].Instances[0].PublicIpAddress" \
              --output text)
            echo "api_url=http://${INSTANCE_IP}:3000" >> $GITHUB_OUTPUT
          fi

      - name: Run smoke tests
        env:
          API_URL: ${{ steps.get-url.outputs.api_url }}
        run: |
          echo "Running smoke tests against $API_URL"

          # Test health endpoint
          echo "Testing /health..."
          curl -sf "$API_URL/health" | jq . || exit 1

          # Test auth config endpoint
          echo "Testing /auth/config..."
          curl -sf "$API_URL/auth/config" | jq . || exit 1

          # Test that note routes require authentication (should return 401)
          echo "Testing /notes requires auth..."
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$API_URL/notes")
          if [ "$STATUS" != "401" ]; then
            echo "Expected 401 for unauthenticated /notes, got $STATUS"
            exit 1
          fi
          echo "Auth check passed (401 as expected)"

          echo "All smoke tests passed!"

      - name: Notify deployment success
        if: success()
        env:
          DEPLOY_ENV: ${{ needs.build.outputs.deploy_env }}
        run: |
          echo "Deployment successful!"
          echo "Environment: $DEPLOY_ENV"
          echo "Commit: ${{ github.sha }}"
          echo "API URL: ${{ steps.get-url.outputs.api_url }}"
